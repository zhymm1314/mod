---
description: 
globs: 
alwaysApply: false
---
# 交流模式指南

## 概述
本指南定义了与AI助手交流时的不同模式，每个模式都有特定的规则和流程。使用时请在对话开始时用 `[模式名]` 来声明当前模式。

**重要**: 每个模式完成后都必须生成相应的文档，以便后续模式能够理解和继承前一阶段的工作成果。

## 模式流程
模式之间具有上下文关系和逻辑顺序：

```
[需求分析] → [开发模式] → [调试模式] → [测试模式] → [总结模式]
     ↓                                                    ↑
[全能模式] (适用于简单需求的一站式完成) ──────────────────────┘
```

每个模式的输出会作为下一个模式的输入，通过文档形式确保整个开发流程的连贯性。

## 模式定义

### [需求分析] - 需求梳理和澄清模式
**使用场景**: 当你有一个想法或需求，需要进一步分析和明确时使用

**规则**:
- AI会主动提问来澄清需求细节
- 重点关注功能范围、技术选型、用户体验等方面
- 会提供多种实现方案供选择
- 结束时会给出详细的需求总结和实现建议
- **必须生成**: `需求分析文档` - 包含需求描述、功能清单、技术方案、验收标准等

**输出文档格式**:
```markdown
# 需求分析文档

## 项目概述
- 项目名称: [项目名称]
- 项目描述: [详细描述]
- 目标用户: [目标用户群体]

## 功能需求
### 核心功能
1. [功能1] - [详细描述]
2. [功能2] - [详细描述]

### 非功能需求
- 性能要求: [性能指标]
- 安全要求: [安全要求]
- 兼容性要求: [兼容性要求]

<!-- ## 技术方案
- 前端技术栈: [技术选择和理由]
- 后端技术栈: [技术选择和理由]
- 数据库方案: [数据库选择和设计] -->

## 验收标准
1. [验收条件1]
2. [验收条件2]

## 风险评估
- 技术风险: [识别的风险和应对措施]
- 时间风险: [时间评估和关键路径]
```

**示例**: `[需求分析] 我想做一个用户管理系统`

### [开发模式] - 代码编写和实现模式
**使用场景**: 需求已明确，开始具体编码实现时使用

**规则**:
- 基于需求分析文档进行代码编写
- 直接进行代码编写，减少冗余讨论
- 优先考虑代码质量、性能和可维护性
- 会主动添加必要的注释和错误处理
- **前端开发**: 严格遵循 [frontend-guide.mdc](mdc:frontend-guide.mdc) 的开发规范
  - 使用Vue 3 + Composition API
  - 遵循组件开发规范和样式规范
  - 实现响应式设计和API集成
- **后端开发**: 严格遵循 [backend-guide.mdc](mdc:backend-guide.mdc) 的开发规范
  - 使用Go + Gin框架的MVC架构
  - 遵循控制器、服务、模型分层设计
  - 实现认证授权和数据库操作
- **必须生成**: `开发实现文档` - 包含代码结构、API接口、数据库设计、部署说明等

**输出文档格式**:
```markdown
# 开发实现文档

## 基于需求
参考文档: [需求分析文档链接]

## 代码结构
### 前端结构
- 组件目录: [组件说明]
- 页面路由: [路由配置]
- 状态管理: [状态管理方案]

### 后端结构
- 控制器层: [控制器说明]
- 服务层: [服务层说明]
- 模型层: [模型层说明]

## API接口设计
### 认证接口
- POST /api/auth/login - 用户登录
- POST /api/auth/register - 用户注册

### 业务接口
- GET /api/users - 获取用户列表
- POST /api/users - 创建用户

## 数据库设计
### 用户表 (users)
- id: 主键
- name: 用户名
- mobile: 手机号

## 配置说明
- 环境变量: [环境变量说明]
- 配置文件: [配置文件说明]

## 部署说明
- 前端部署: [部署步骤]
- 后端部署: [部署步骤]
```

**示例**: 
- `[开发模式-前端] 基于需求分析文档，实现用户登录页面`
- `[开发模式-后端] 基于需求分析文档，实现用户登录API接口`

### [调试模式] - 问题诊断和修复模式
**使用场景**: 代码出现bug或异常，需要定位和修复问题时使用

**规则**:
- 基于开发实现文档的代码进行问题分析
- 系统性分析错误信息和日志
- 提供step-by-step的调试步骤
- 会要求提供相关的错误信息、代码片段和环境信息
- 给出根因分析和修复方案
- 提供预防类似问题的建议
- **必须生成**: `调试修复文档` - 包含问题描述、根因分析、修复方案、预防措施等

**输出文档格式**:
```markdown
# 调试修复文档

## 基于实现
参考文档: [开发实现文档链接]

## 问题描述
- 问题现象: [详细描述问题表现]
- 错误信息: [具体错误信息]
- 重现步骤: [问题重现的步骤]

## 问题分析
- 问题定位: [问题发生的具体位置]
- 根因分析: [问题产生的根本原因]
- 影响范围: [问题影响的功能范围]

## 修复方案
### 代码修改
- 文件: [修改的文件路径]
- 修改内容: [具体修改内容]
- 修改原因: [为什么这样修改]

### 配置调整
- 配置项: [调整的配置]
- 调整说明: [配置调整说明]

## 验证测试
- 测试步骤: [验证修复的测试步骤]
- 测试结果: [测试结果说明]

## 预防措施
- 代码改进: [避免类似问题的代码改进建议]
- 监控告警: [相关监控和告警建议]
```

**示例**: `[调试模式] 开发实现的登录接口返回500错误`

### [测试模式] - 测试策略和执行模式
**使用场景**: 需要对功能进行测试验证时使用

**规则**:
- 基于调试修复文档的稳定代码进行测试设计
- 严格遵循 [testing-guide.mdc](mdc:testing-guide.mdc) 的测试规范
- 制定全面的测试计划（单元测试、集成测试、端到端测试）
- 生成测试用例和测试数据
- 提供自动化测试脚本
- 关注边界条件和异常情况
- 给出测试覆盖率和质量评估
- **必须生成**: `测试报告文档` - 包含测试计划、测试用例、测试结果、质量评估等

**输出文档格式**:
```markdown
# 测试报告文档

## 基于修复
参考文档: [调试修复文档链接]

## 测试计划
### 测试范围
- 功能测试: [测试的功能模块]
- 性能测试: [性能测试范围]
- 安全测试: [安全测试范围]

### 测试环境
- 测试环境: [测试环境描述]
- 测试数据: [测试数据说明]

## 测试用例
### 单元测试
- 测试类: [测试类名称]
- 测试方法: [测试方法列表]
- 覆盖率: [代码覆盖率]

### 集成测试
- API测试: [API接口测试用例]
- 数据库测试: [数据库操作测试]

### 端到端测试
- 用户流程: [完整用户操作流程测试]
- 浏览器兼容: [浏览器兼容性测试]

## 测试结果
- 通过用例: [通过的测试用例数量]
- 失败用例: [失败的测试用例和原因]
- 缺陷统计: [发现的缺陷统计]

## 质量评估
- 功能完整性: [功能实现完整度评估]
- 性能指标: [性能测试结果]
- 安全评估: [安全测试结果]

## 上线建议
- 上线条件: [满足上线的条件]
- 风险评估: [上线风险评估]
- 监控建议: [生产环境监控建议]
```

**示例**: `[测试模式] 测试调试完成的用户登录功能`

### [全能模式] - 一站式开发模式
**使用场景**: 需求相对简单，希望一次性完成分析、开发、调试、测试的全流程时使用

**规则**:
- 快速分析需求并确认关键细节
- 直接进行代码实现，包含基本的错误处理
- 遵循对应的开发规范（前端遵循frontend-guide，后端遵循backend-guide）
- 主动识别和修复明显问题
- 提供基础测试用例和验证方法
- 给出完整的实现方案和使用说明
- **必须生成**: `全能模式完整文档` - 包含需求、实现、测试的完整记录
- **适用范围**: 功能相对独立、逻辑不复杂的需求

**输出文档格式**:
```markdown
# 全能模式完整文档

## 需求分析
- 功能描述: [简要功能描述]
- 技术选型: [技术选择]

## 实现方案
- 代码结构: [代码组织结构]
- 关键实现: [关键代码说明]

## 测试验证
- 测试用例: [基础测试用例]
- 验证结果: [功能验证结果]

## 使用说明
- 部署步骤: [部署说明]
- 使用方法: [使用方法]
```

**示例**: `[全能模式] 实现一个简单的密码加密工具函数`

### [总结模式] - 经验沉淀和文档更新模式
**使用场景**: 完成开发任务后，需要将实践经验、解决方案、最佳实践沉淀到技术规范文档中时使用

**规则**:
- 基于前面任何模式的实践经验进行总结
- 识别可复用的解决方案、最佳实践、常见问题等
- **自动更新技术规范文档**:
  - 前端相关经验更新到 `.cursor/rules/frontend-guide.mdc`
  - 后端相关经验更新到 `.cursor/rules/backend-guide.mdc`  
  - 测试相关经验更新到 `.cursor/rules/testing-guide.mdc`
  - 通用开发经验更新到相应的技术文档
- 将具体的问题解决方案抽象为通用的指导原则
- 补充代码示例、配置模板、调试技巧等实用内容
- **必须生成**: `经验总结文档` + **更新对应的技术规范文档**

**输出文档格式**:
```markdown
# 经验总结文档

## 基于实践
参考文档: [前置模式文档链接]

## 关键发现
### 问题类型
- 问题描述: [遇到的具体问题]
- 问题分类: [前端/后端/测试/部署等]
- 影响范围: [问题的影响范围]

### 解决方案
- 解决思路: [解决问题的思路]
- 具体方法: [具体的解决方法]
- 关键代码: [关键代码片段]

## 最佳实践提炼
### 设计原则
- 原则1: [提炼的设计原则]
- 原则2: [提炼的设计原则]

### 实现模式
- 模式名称: [可复用的实现模式]
- 适用场景: [模式的适用场景]
- 代码模板: [标准代码模板]

### 避免陷阱
- 常见错误: [容易犯的错误]
- 预防措施: [预防措施]

## 文档更新记录
- 更新文档: [更新的技术规范文档名称]
- 更新内容: [具体更新的章节和内容]
- 更新原因: [为什么要更新这些内容]

## 后续建议
- 推广应用: [如何在其他项目中应用]
- 持续改进: [进一步优化的方向]
```

**自动文档更新规则**:
1. **前端问题** → 更新 `.cursor/rules/frontend-guide.mdc`:
   - CSS布局问题 → 更新"网格布局设计规范"章节
   - Vue组件问题 → 更新"组件开发规范"章节
   - 响应式问题 → 更新"响应式设计"章节
   - 性能问题 → 更新"性能优化"章节

2. **后端问题** → 更新 `.cursor/rules/backend-guide.mdc`:
   - API设计问题 → 更新"API设计规范"章节
   - 数据库问题 → 更新"数据库设计"章节
   - 认证问题 → 更新"认证授权"章节
   - 性能问题 → 更新"性能优化"章节
   - 项目结构问题 → 更新"项目结构规范"章节
   - 日志管理问题 → 更新"日志管理规范"章节

3. **测试问题** → 更新 `.cursor/rules/testing-guide.mdc`:
   - 测试策略 → 更新"测试策略"章节
   - 测试工具 → 更新"测试工具"章节
   - 自动化测试 → 更新"自动化测试"章节

4. **通用问题** → 创建或更新对应的专项文档

**示例**: 
- `[总结模式] 总结CSS Grid网格布局的调试经验`
- `[总结模式] 总结API接口设计的最佳实践`
- `[总结模式] 总结前端性能优化的实践经验`
- `[总结模式] 总结后端日志目录结构调整的最佳实践`

## 上下文传递规则

1. **模式切换时保持上下文**: 切换到下一个模式时，明确引用前一个模式的输出文档
2. **状态同步**: 每个模式开始时会确认当前的项目状态和前置文档
3. **问题追溯**: 在调试和测试阶段发现问题时，可以追溯到开发甚至需求分析文档
4. **迭代优化**: 支持在任何阶段回到前面的模式进行优化和调整，并更新相应文档
5. **文档链接**: 每个文档都要明确引用依赖的前置文档，形成完整的文档链

## 使用指南

1. **选择起始模式**: 
   - 复杂需求从 `[需求分析]` 开始
   - 简单需求可以直接使用 `[全能模式]`
   - 已有明确需求可以从 `[开发模式]` 开始
   - 任务完成后使用 `[总结模式]` 沉淀经验

2. **模式流转**: 
   - 自然流转：按照 需求分析 → 开发 → 调试 → 测试 → 总结 的顺序
   - 跳跃流转：可以跳过某些阶段，但需要明确说明并补充必要文档
   - 回退流转：发现问题时可以回到前面的阶段，并更新相关文档
   - **总结流转**：任何模式完成后都可以进入总结模式进行经验沉淀

3. **文档维护**: 
   - 每次模式切换时要检查前置文档的完整性和准确性
   - **总结模式会自动更新技术规范文档**，确保经验得到沉淀

4. **灵活应用**: 根据实际情况调整流程，但必须保证文档的连续性

5. **经验积累**: 
   - 重要问题解决后必须进入总结模式
   - 定期回顾和更新技术规范文档
   - 将个人经验转化为团队知识资产

## 注意事项

- **文档生成是强制要求**: 每个模式完成后必须生成对应的文档
- 模式间的上下文传递通过文档实现，确保信息不丢失
- 复杂项目建议按完整流程执行，简单需求可使用全能模式
- 在任何阶段都可以返回前面的模式进行调整，但要同步更新文档
- 保持每个阶段输出文档的完整性，为下一阶段提供充分信息
- 开发和测试阶段必须遵循对应的技术规范指南
- **总结模式的特殊职责**: 
  - 必须同时生成经验总结文档和更新技术规范文档
  - 将具体问题抽象为通用解决方案
  - 确保经验能够被后续项目复用
- **文档命名规范**: 建议使用项目名称 + 模式名称的方式命名文档
- **技术规范文档的持续更新**: 通过总结模式确保技术文档与实践经验同步
